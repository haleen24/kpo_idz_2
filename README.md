Для запуска программы - из корневого каталога проекта собрать и поднять docker-compose, после чего запустить
src/main/kotlin/Application.kt

Сервер поднимется на localhost:8080.

Для базы данных в docker-compose используются volume. Первый запуск контейнера создает все таблицы, а так же добавляет
пользователя admin-admin

Для входа - перейдите по localhost:8080/login/

В окно регистрации можно попасть через окно авторизации

Пароли сохраняются в бд при помощи sha256, слежение за авторизацией пользоветелей происходит при помощи
spring boot security

После авторизации пользователю будет выведено функциональное меню:

* Просмотр меню ресторана
* Просмотр заказов

Для админов так же будет доступно:

* Добавление блюда
* Добавление пользователя-админа
* Просмотр статистики

При просмотре меню ресторана можно добавлять блюда в корзину (add to cart), после добавления блюда, в корзине можно
указать нужное количество. Так же можно просмотреть отзывы на блюдо. При этом админ может обновлять количество блюд -
указывая в соответствующих формах новое значение. При установке значения=0, блюдо удаляется.

Коризна отрисовывается в правой части экрана с меню. В низу корзины есть кнопка создания саказа (create order).

При создании заказа - если у пользователя был заказ, который находился в стадии обработки (processing), новый
отправленный заказ добавляется к такому заказу.
Иначе формируется новый заказ.

Изначально есть 7 поваров. Шесть из них работают в порядке обычной очереди, а один из них - только на быстрые заказы.
Это позволяет приоритезировать заказы в очереди: кухня всегда сможет отдавать быстрые заказы, отдавая им приоритет
быстрого повара (по умолчанию время 30 секунд (данное время выбрано, для демонстрации работоспособности этой механики))

При просмотре заказов страничка обновляется раз в 4 секунды, благодаря этому удается в реальном времени отслеживать
статус заказа

Пока заказ в обработке или готовится (processing/cooking) - его можно отменить.
При в качестве условности все блюда из данных заказов будут возвращены "на склад".

Заказы поступают на кухню, которая выстраивает их в общую очередь для поворов (унаследованных от Thread).
Каждый повор перед тем, как взять заказ - блокирует доступ к общей очереди.

При отмене заказа - объекту повара приходит прерывание, после чего происходит копирование повара и его перезапуск.

Пользователь может оплатить заказ после того, как его статус станет готов (done). После этого пользователь сможет
оставить отзыв на каждое блюдо из заказа.
При этом важная особенность - отзыв требует уникальности тройки из id пользователя, id блюда и id заказа.
Это позволяет пользователям оставлять несколько отзывов на одно и то же блюдо из разных заказов.
При этом при попытке повторного оставления отзыва - отзыв будет перезаписан.

Программа сохраняет:

* меню из блюд
* пользователей в системе
* заказы
* отношение заказ-пользователь-блюдо
* отзывы

Так же при перезапуске сервера, кухня в первую очередь ищет в базе данных незаконченные заказы и делает их по-новой.

Администратор может добавлять блюдо, для этого ему надо перейти в соответствующую вкладку в функциональном меню на
главной странице и заполнить все данные в форму

Администратор может просматривать статистику о пользователях в системе и об оплаченных заказов.
Для заказов есть 3 фильтра - по частоте покупок (общее количество проданного), по среднем отзывам и по доходу.
Так же доступен фильтр по id - можно указать начало и конец id блюд, для которых админ хочет просмотреть статистику
(изначально флаг на чек-боксе select-all не стоит, но выбраны все значения - к сожалению, автор не знает как решить эту
проблему)

Шаблоны проектирования:

* Шаблонный метод - абстрактный класс AbstractCook содержит в себе определение общего поведения повара, и абстрактные
  методы конкретного поведения.
  Классы Cook и LowTimeCook унаследованы от данного абстрактного класса и переопределяют метод getCurrentId - для поиска
  заказа в очереди (обычный повар берет самый первый заказ, в то время как быстрый повар берет заказы, которые не
  занимают больше некоторого заранее известного времени)
* Адаптер - в etc/encoder написан класс, который методы шифровки из основного приложения адаптирует под конфигурацию для
  sprig boot security
* Фасад - основное приложение RestaurantSystem является фасадом для набора классов связанных с базами данных и кухней.
  Содержит внутри себя каждый из классов, предоставляя пользователю возможность делать запросы к одной структуре,
  которая помимо предоставления данных делает составные часто используемые операции на данных классах.
* Прототип - используется для восстановления новых потоков, реализован как метод copy() в AbstractCook, копирует все
  данные объекта потока в новый объект.
* Строитель - В etc класс OrderBuilder - строит заказ на основе словаря <имя блюда: информацию о заказе конкретного
  блюда>  